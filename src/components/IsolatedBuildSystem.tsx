/**
 * IsolatedBuildSystem - Builds apps using isolated modules with shared type contracts
 * 
 * Architecture:
 * 1. Generate Contracts (types/) - from PRD data model
 * 2. Generate Shell (App.tsx, configs) - routing only, no logic
 * 3. Build Shared UI (components/ui/) - primitives all modules use
 * 4. Build Feature Modules - each sees ONLY types + shared + own folder
 * 5. Integration - wire up, test full app
 * 
 * Key insight: AI over-builds when it sees full context. 
 * Isolation prevents this by limiting what each step can see.
 */

import { useState, useRef, useEffect } from 'react'
import CodePanel from './CodePanel'
import { getPluginSettings } from './SettingsPanel'
import { getSystemPrompt, getModelForStep, getBuildSettings, BuildStepType, parseCompletionSignal, cleanModuleName, cleanRoutePath } from '../lib/prompts'
import { 
  initProgressLog, 
  logStepStart, 
  logStepComplete, 
  logStepFailed, 
  writeProgressLog 
} from '../lib/progressLog'
import { IconBuild, IconCheck, IconClock, IconCode, IconDocument, IconRocket, IconRefresh } from './Icons'
import { usePlaywrightTest } from '../hooks/usePlaywrightTest'

// Build step types
type BuildStepType = 'contracts' | 'shell' | 'shared' | 'module' | 'integration'

interface BuildStep {
  id: string
  type: BuildStepType
  name: string
  description: string
  status: 'pending' | 'building' | 'complete' | 'failed'
  moduleSpec?: ModuleSpec  // For module steps
  filesCreated: string[]
}

interface ModuleSpec {
  name: string
  route: string
  description: string
  components: string[]  // Expected components to build
}

interface Project {
  id: string
  name: string
  status?: string  // Add status to check if coming from 'building'
  prd: {
    overview: { name: string; description: string; platform: string }
    features: Array<{ id: string; title: string; description: string }>
    dataModel?: { entities: Array<{ name: string; fields: string }> }
    screens?: Array<{ id: string; name: string; description: string }>
    designNotes?: string
  }
  modules?: any[]
  buildSteps?: BuildStep[]
}

interface IsolatedBuildSystemProps {
  project: Project
  onProjectUpdate: (project: Project) => void
  apiKey: string
  provider?: string
  model?: string
  autoGenerate?: boolean  // New prop to trigger auto-generation
  onRuntimeError?: (error: { message: string; file?: string; line?: number }) => void  // Runtime error callback
}

export default function IsolatedBuildSystem({ 
  project, 
  onProjectUpdate, 
  apiKey, 
  provider = 'anthropic', 
  model = 'claude-sonnet-4-20250514',
  onRuntimeError
}: IsolatedBuildSystemProps) {
  const [buildSteps, setBuildSteps] = useState<BuildStep[]>(project.buildSteps || [])
  const [currentStepIndex, setCurrentStepIndex] = useState<number | null>(null)
  const [buildLog, setBuildLog] = useState<string[]>([])
  const [isBuilding, setIsBuilding] = useState(false)
  const [stopRequested, setStopRequested] = useState(false)
  const [hasBuildErrors, setHasBuildErrors] = useState(false)
  const [previewUrl, setPreviewUrl] = useState<string | null>(null)
  const [previewFailed, setPreviewFailed] = useState(false)
  const [capturedErrors, setCapturedErrors] = useState<Set<string>>(new Set())
  const [rightPanelTab, setRightPanelTab] = useState<'code' | 'preview'>('preview')
  const [lastFileUpdate, setLastFileUpdate] = useState(Date.now())
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false)
  const webviewRef = useRef<any>(null)
  
  // Per-step timer state
  const [stepStartTime, setStepStartTime] = useState<number | null>(null)
  const [stepEstimate, setStepEstimate] = useState<number>(0)
  const [stepRemaining, setStepRemaining] = useState<number>(0)

  // Self-healing: code context for retry attempts
  const [retryContext, setRetryContext] = useState<{ code: string; error?: string } | null>(null)

  // Total build time tracking
  const [totalBuildStart, setTotalBuildStart] = useState<number | null>(null)
  const [totalElapsed, setTotalElapsed] = useState<number>(0)

  // Sub-task progress for module builds
  const [subTaskProgress, setSubTaskProgress] = useState<{
    current: number
    total: number
    name: string
  } | null>(null)

  // v1.5.0: Playwright testing
  const { isRunning: isTestRunning, lastResult: testResult, runSmokeTest } = usePlaywrightTest()
  const [testStatus, setTestStatus] = useState<'idle' | 'running' | 'passed' | 'failed'>('idle')

  // Get step timing history from localStorage
  const getStepHistory = (stepType: string): number[] => {
    try {
      const history = localStorage.getItem(`jett-step-${stepType}`)
      return history ? JSON.parse(history) : []
    } catch { return [] }
  }

  // Save step time to history
  const saveStepTime = (stepType: string, seconds: number) => {
    const history = getStepHistory(stepType)
    history.push(seconds)
    const trimmed = history.slice(-5) // Keep last 5
    localStorage.setItem(`jett-step-${stepType}`, JSON.stringify(trimmed))
  }

  // Estimate step time based on type
  const estimateStepTime = (step: BuildStep): number => {
    const stepType = step.type || 'module'
    const history = getStepHistory(stepType)
    
    if (history.length > 0) {
      return Math.round(history.reduce((a, b) => a + b, 0) / history.length)
    }
    
    // Default estimates by type
    const defaults: Record<string, number> = {
      'types': 15,
      'shell': 20,
      'shared-ui': 25,
      'module': 30,
      'integration': 10
    }
    return defaults[stepType] || 25
  }

  // Start step timer
  const startStepTimer = (step: BuildStep) => {
    const estimate = estimateStepTime(step)
    setStepStartTime(Date.now())
    setStepEstimate(estimate)
    setStepRemaining(estimate)
  }

  // Stop step timer and save
  const stopStepTimer = (step: BuildStep) => {
    if (stepStartTime) {
      const elapsed = Math.floor((Date.now() - stepStartTime) / 1000)
      saveStepTime(step.type || 'module', elapsed)
    }
    setStepStartTime(null)
    setStepEstimate(0)
    setStepRemaining(0)
  }

  // Countdown timer effect for current step
  useEffect(() => {
    if (!stepStartTime) return

    const interval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - stepStartTime) / 1000)
      const remaining = Math.max(0, stepEstimate - elapsed)
      setStepRemaining(remaining)
    }, 1000)

    return () => clearInterval(interval)
  }, [stepStartTime, stepEstimate])

  // Total build time counter (counts up)
  useEffect(() => {
    if (!totalBuildStart) return

    const interval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - totalBuildStart) / 1000)
      setTotalElapsed(elapsed)
    }, 1000)

    return () => clearInterval(interval)
  }, [totalBuildStart])

  // Format seconds as MM:SS
  const formatTime = (seconds: number): string => {
    const mins = Math.floor(seconds / 60)
    const secs = seconds % 60
    return `${mins}:${secs.toString().padStart(2, '0')}`
  }

  const log = (message: string) => {
    setBuildLog(prev => [...prev, `[${new Date().toLocaleTimeString()}] ${message}`])
    console.log(message)
  }

  // Capture console errors from webview preview
  useEffect(() => {
    const webview = webviewRef.current
    if (!webview || !previewUrl || !onRuntimeError) return

    const handleConsoleMessage = (event: any) => {
      // event.level: 0=verbose, 1=info, 2=warning, 3=error
      if (event.level >= 2) { // Warnings and errors
        const message = event.message
        
        // Skip duplicates
        if (capturedErrors.has(message)) return
        
        // Skip Vite HMR messages
        if (message.includes('[vite]') || message.includes('hmr')) return
        
        // Parse error for file info
        let file: string | undefined
        let line: number | undefined
        
        // Try to extract file path from stack trace or message
        const fileMatch = message.match(/src\/[^:\s]+\.(tsx?|jsx?)/)
        if (fileMatch) {
          file = fileMatch[0]
        }
        
        const lineMatch = message.match(/:(\d+):\d+/)
        if (lineMatch) {
          line = parseInt(lineMatch[1], 10)
        }
        
        // Add to captured set
        setCapturedErrors(prev => new Set(prev).add(message))
        
        // Report error
        onRuntimeError({
          message: message.slice(0, 200), // Truncate long messages
          file,
          line
        })
        
        log(`  ‚ö†Ô∏è Runtime error: ${message.slice(0, 100)}...`)
      }
    }

    // Wait for webview to be ready
    const setupListener = () => {
      webview.addEventListener('console-message', handleConsoleMessage)
    }

    if (webview.getWebContentsId) {
      setupListener()
    } else {
      webview.addEventListener('dom-ready', setupListener)
    }

    return () => {
      webview.removeEventListener('console-message', handleConsoleMessage)
      webview.removeEventListener('dom-ready', setupListener)
    }
  }, [previewUrl, onRuntimeError, capturedErrors])

  // Generate build steps from PRD (supports incremental builds)
  const generateBuildPlan = async () => {
    log('üìã Analyzing build plan...')
    
    const existingSteps = buildSteps || []
    const features = project.prd?.features || []
    
    // Get existing module step names to detect what's already planned
    const existingModuleNames = new Set(
      existingSteps
        .filter(s => s.type === 'module')
        .map(s => s.name)
    )
    
    // Find new features not yet in build plan
    const newFeatures = features.filter(f => !existingModuleNames.has(f.title))
    
    // If no existing steps, generate fresh plan
    if (existingSteps.length === 0) {
      log('üìã Generating fresh build plan...')
      const steps: BuildStep[] = []
      
      // Step 1: Contracts
      steps.push({
        id: 'step-contracts',
        type: 'contracts',
        name: 'Type Contracts',
        description: 'Generate shared types from PRD data model',
        status: 'pending',
        filesCreated: []
      })
      
      // Step 2: Shell
      steps.push({
        id: 'step-shell',
        type: 'shell',
        name: 'App Shell',
        description: 'Create routing structure and config files',
        status: 'pending',
        filesCreated: []
      })
      
      // Step 3: Shared UI
      steps.push({
        id: 'step-shared',
        type: 'shared',
        name: 'Shared UI',
        description: 'Build reusable UI components (Button, Card, Modal, Input)',
        status: 'pending',
        filesCreated: []
      })
      
      // Step 4+: All feature modules
      features.forEach((feature, idx) => {
        const moduleName = cleanModuleName(feature.title)
        const routePath = cleanRoutePath(moduleName)
        steps.push({
          id: `step-module-${idx}`,
          type: 'module',
          name: feature.title,
          description: feature.description,
          status: 'pending',
          moduleSpec: {
            name: moduleName,
            route: routePath,
            description: feature.description,
            components: [`${moduleName}Page`, `${moduleName}List`, `${moduleName}Detail`]
          },
          filesCreated: []
        })
      })
      
      // Final step: Integration
      steps.push({
        id: 'step-integration',
        type: 'integration',
        name: 'Integration',
        description: 'Wire up modules, test full app',
        status: 'pending',
        filesCreated: []
      })
      
      setBuildSteps(steps)
      onProjectUpdate({ ...project, buildSteps: steps })
      log(`‚úÖ Generated ${steps.length} build steps`)
      return
    }
    
    // Incremental: Add new features to existing plan
    if (newFeatures.length > 0) {
      log(`üìã Found ${newFeatures.length} new feature(s) to add...`)
      
      // Find where to insert (before integration step)
      const integrationIndex = existingSteps.findIndex(s => s.type === 'integration')
      const insertIndex = integrationIndex !== -1 ? integrationIndex : existingSteps.length
      
      // Create new module steps
      const newModuleSteps: BuildStep[] = newFeatures.map((feature, idx) => {
        const moduleName = cleanModuleName(feature.title)
        const routePath = cleanRoutePath(moduleName)
        return {
          id: `step-module-${Date.now()}-${idx}`,
          type: 'module' as BuildStepType,
          name: feature.title,
          description: feature.description,
          status: 'pending' as const,
          moduleSpec: {
            name: moduleName,
            route: routePath,
            description: feature.description,
            components: [`${moduleName}Page`, `${moduleName}List`, `${moduleName}Detail`]
          },
          filesCreated: []
        }
      })
      
      // Insert new steps before integration
      const updatedSteps = [
        ...existingSteps.slice(0, insertIndex),
        ...newModuleSteps,
        ...existingSteps.slice(insertIndex)
      ]
      
      // Reset integration step to pending (needs to re-run with new modules)
      const finalSteps = updatedSteps.map(s => 
        s.type === 'integration' ? { ...s, status: 'pending' as const } : s
      )
      
      setBuildSteps(finalSteps)
      onProjectUpdate({ ...project, buildSteps: finalSteps })
      log(`‚úÖ Added ${newFeatures.length} new module(s) - ready to build`)
      
      newFeatures.forEach(f => log(`  + ${f.title}`))
      return
    }
    
    // No changes needed
    log('‚úÖ Build plan is up to date')
  }

  // Auto-generate build plan when arriving from PRD with status='building'
  useEffect(() => {
    if (project.status === 'building' && buildSteps.length === 0 && !hasAutoGenerated && apiKey) {
      setHasAutoGenerated(true)
      generateBuildPlan()
    }
  }, [project.status, buildSteps.length, hasAutoGenerated, apiKey])

  // Execute a single build step
  const executeBuildStep = async (step: BuildStep, stepIndex: number): Promise<boolean> => {
    log(`\nüî® Building: ${step.name}`)
    
    // Update status to building and start timer
    updateStepStatus(stepIndex, 'building')
    startStepTimer(step)
    
    try {
      let success = false
      
      switch (step.type) {
        case 'contracts':
          success = await buildContracts()
          break
        case 'shell':
          success = await buildShell()
          break
        case 'shared':
          success = await buildSharedUI()
          break
        case 'module':
          success = await buildModule(step.moduleSpec!)
          // Run simplification pass if module built successfully AND plugin is enabled
          if (success && getPluginSettings().codeSimplifier) {
            await simplifyModule(step.moduleSpec!.name, stepIndex)
          }
          break
        case 'integration':
          success = await runIntegration()
          break
      }
      
      // Stop timer and save
      stopStepTimer(step)
      updateStepStatus(stepIndex, success ? 'complete' : 'failed')
      return success
    } catch (error: any) {
      stopStepTimer(step)
      log(`‚ùå Error: ${error.message}`)
      updateStepStatus(stepIndex, 'failed')
      return false
    }
  }

  const updateStepStatus = (index: number, status: BuildStep['status']) => {
    setBuildSteps(prev => {
      const updated = [...prev]
      updated[index] = { ...updated[index], status }
      onProjectUpdate({ ...project, buildSteps: updated })
      return updated
    })
  }

  /**
   * Read all generated project files for AI context (self-healing)
   */
  const readAllProjectFiles = async (): Promise<string> => {
    try {
      const result = await window.jett.listFiles(project.id)
      if (!result.success) return ''
      
      const codeFiles = result.files.filter((f: string) => 
        (f.endsWith('.tsx') || f.endsWith('.ts') || f.endsWith('.css')) &&
        !f.includes('node_modules')
      )
      
      const fileContents: string[] = []
      for (const file of codeFiles.slice(0, 15)) {
        try {
          const readResult = await window.jett.readFile(project.id, file)
          if (readResult.success && readResult.content.length < 8000) {
            fileContents.push(`// === ${file} ===\n${readResult.content}`)
          }
        } catch (e) { /* skip */ }
      }
      
      return fileContents.join('\n\n')
    } catch (e) {
      return ''
    }
  }

  /**
   * Apply patches from AI response
   * Format: ---PATCH path="filepath"---\nOLD:\n```\nold code\n```\nNEW:\n```\nnew code\n```\n---END-PATCH---
   */
  const applyPatches = async (response: string): Promise<{ applied: number; failed: number }> => {
    const patchRegex = /---PATCH path="([^"]+)"---\s*\nOLD:\s*\n```[^\n]*\n([\s\S]*?)\n```\s*\nNEW:\s*\n```[^\n]*\n([\s\S]*?)\n```\s*\n---END-PATCH---/g
    
    let applied = 0
    let failed = 0
    let match
    
    while ((match = patchRegex.exec(response)) !== null) {
      const [, filePath, oldStr, newStr] = match
      log(`  üîß Patching: ${filePath}`)
      
      const result = await window.jett.patchFile(project.id, filePath, oldStr.trim(), newStr.trim())
      if (result.success) {
        applied++
        log(`    ‚úÖ Patch applied`)
      } else {
        failed++
        log(`    ‚ùå Failed: ${result.error}`)
      }
    }
    
    return { applied, failed }
  }

  const addFilesToStep = (index: number, files: string[]) => {
    setBuildSteps(prev => {
      const updated = [...prev]
      updated[index] = { 
        ...updated[index], 
        filesCreated: [...updated[index].filesCreated, ...files] 
      }
      return updated
    })
  }

  /**
   * Self-review: AI reviews its own generated code for issues
   * This catches problems BEFORE moving to next step
   * Phase 1: Quick static checks
   * Phase 2: AI review (if static checks pass)
   */
  const selfReviewStep = async (step: BuildStep, stepIndex: number): Promise<{ passed: boolean; issues: string[]; fixes?: string[] }> => {
    const issues: string[] = []
    
    try {
      // Get files created in this step
      const files = step.filesCreated
      if (files.length === 0) {
        return { passed: true, issues: [] }
      }
      
      // Phase 1: Quick static checks (no AI needed)
      log(`  üîç Self-review: checking ${files.length} files...`)
      const fileContents: Record<string, string> = {}
      
      for (const file of files) {
        try {
          const result = await window.jett.readFile(project.id, file)
          if (!result.success) {
            issues.push(`${file} could not be read`)
            continue
          }
          fileContents[file] = result.content
          const content = result.content
          
          // Check for common issues
          if (content.includes('// TODO') || content.includes('// FIXME')) {
            issues.push(`${file} has TODO/FIXME comments`)
          }
          if (content.includes('any[]') || content.includes(': any')) {
            const anyCount = (content.match(/: any/g) || []).length
            if (anyCount > 5) {
              issues.push(`${file} has excessive 'any' types (${anyCount})`)
            }
          }
          if (file.endsWith('.tsx') && !content.includes('export')) {
            issues.push(`${file} has no exports`)
          }
          // Check for missing imports
          if (content.includes('useState') && !content.includes("from 'react'") && !content.includes('from "react"')) {
            issues.push(`${file} uses useState but missing React import`)
          }
        } catch (e) {
          issues.push(`${file} could not be read`)
        }
      }
      
      // Critical issues that should fail immediately
      const criticalIssues = issues.filter(i => 
        i.includes('no exports') || i.includes('could not be read') || i.includes('missing React import')
      )
      
      if (criticalIssues.length > 0) {
        return { passed: false, issues }
      }
      
      // Phase 2: AI review for module steps (optional, can be disabled)
      if (step.type === 'module' && Object.keys(fileContents).length > 0) {
        const aiReview = await aiSelfReview(fileContents, step.moduleSpec!)
        if (!aiReview.passed) {
          issues.push(...aiReview.issues)
          return { passed: false, issues, fixes: aiReview.fixes }
        }
      }
      
      if (issues.length > 0) {
        log(`  ‚ö†Ô∏è Self-review found ${issues.length} warnings (non-blocking)`)
      } else {
        log(`  ‚úÖ Self-review passed`)
      }
      
      return { passed: true, issues }
    } catch (e) {
      // Review failed, but don't block build
      return { passed: true, issues: [] }
    }
  }

  /**
   * AI Self-Review: Ask AI to review its own generated code
   * Uses Haiku for fast, cheap review
   */
  const aiSelfReview = async (
    fileContents: Record<string, string>, 
    spec: ModuleSpec
  ): Promise<{ passed: boolean; issues: string[]; fixes?: string[] }> => {
    // Skip AI review if no API key
    if (!apiKey) {
      return { passed: true, issues: [] }
    }
    
    const filesContext = Object.entries(fileContents)
      .map(([path, content]) => `--- ${path} ---\n${content}`)
      .join('\n\n')
    
    const prompt = `Review this code I just generated for the "${spec.name}" module.

FILES:
${filesContext}

CHECK FOR:
1. Missing imports (useState, useEffect, router hooks)
2. Undefined variables or functions
3. Type mismatches
4. Components without proper exports
5. Broken import paths

RESPOND IN THIS EXACT FORMAT:
PASSED: true/false
ISSUES: (one per line, or "none")
- issue 1
- issue 2

If PASSED is false, the code has critical issues that will cause errors.
Be strict - if there's any import that doesn't exist or undefined reference, fail it.`

    try {
      // Use Haiku for fast, cheap review
      const reviewProvider = provider === 'openrouter' ? 'openrouter' : 'anthropic'
      const reviewModel = provider === 'openrouter' ? 'anthropic/claude-haiku-4.5' : 'claude-haiku-4-5-20251001'
      
      const result = await window.jett.claudeApi(
        apiKey,
        JSON.stringify([{ role: 'user', content: prompt }]),
        undefined,
        reviewProvider,
        reviewModel
      )
      
      if (!result.success) {
        log(`  ‚ö†Ô∏è AI review failed: ${result.error}`)
        return { passed: true, issues: [] }
      }
      
      const response = result.text
      
      // Parse response
      const passedMatch = response.match(/PASSED:\s*(true|false)/i)
      const passed = passedMatch ? passedMatch[1].toLowerCase() === 'true' : true
      
      const issuesMatch = response.match(/ISSUES:([\s\S]*?)(?:$|FIXES:)/i)
      const issues: string[] = []
      
      if (issuesMatch && !issuesMatch[1].includes('none')) {
        const issueLines = issuesMatch[1].split('\n').filter((l: string) => l.trim().startsWith('-'))
        issues.push(...issueLines.map((l: string) => l.replace(/^-\s*/, '').trim()))
      }
      
      if (!passed) {
        log(`  ‚ùå AI review failed: ${issues.join(', ')}`)
      }
      
      return { passed, issues }
    } catch (e) {
      // AI review failed, don't block
      return { passed: true, issues: [] }
    }
  }

  // ========================================
  // BUILD STEP IMPLEMENTATIONS
  // ========================================

  /**
   * Step 1: Generate Type Contracts
   * Input: PRD data model
   * Output: types/models.ts, types/components.ts, types/index.ts
   */
  const buildContracts = async (): Promise<boolean> => {
    const dataModel = project.prd?.dataModel
    const features = project.prd?.features || []
    
    const prompt = `Generate TypeScript type definitions for this app:

App: ${project.prd?.overview?.name || 'App'}
Description: ${project.prd?.overview?.description || ''}

Data Entities:
${dataModel?.entities?.map(e => `- ${e.name}: ${e.fields}`).join('\n') || 'None specified - infer from features'}

Features:
${features.map(f => `- ${f.title}: ${f.description}`).join('\n')}

Generate THREE files:

1. types/models.ts - Core data types (entities, state)
2. types/components.ts - Component prop interfaces (ButtonProps, CardProps, ModalProps, InputProps, plus domain-specific props)
3. types/index.ts - Re-export everything

Use this exact format for each file:
---FILE-START path="src/types/models.ts"---
code here
---FILE-END---

Make types comprehensive but not over-engineered. Include:
- All data entities with proper typing
- Status enums where appropriate  
- Action types for state management
- React.ReactNode for children props`

    return await executeAIStep(prompt, 0)
  }

  /**
   * Step 2: Generate App Shell
   * Input: Types + route list
   * Output: Placeholder App.tsx, main.tsx, configs (NO routing yet)
   */
  const buildShell = async (): Promise<boolean> => {
    const prompt = `Generate the app shell for: ${project.prd?.overview?.name || 'App'}

Generate these files:

1. package.json - Vite + React + TypeScript + Tailwind + react-router-dom
2. vite.config.ts - with @ alias for src
3. tsconfig.json - with path aliases
4. tailwind.config.js
5. postcss.config.js  
6. index.html
7. src/main.tsx - simple React root render (NO BrowserRouter yet)
8. src/index.css - Tailwind imports + dark mode base styles
9. src/App.tsx - PLACEHOLDER only (see below)

CRITICAL - App.tsx must be this simple placeholder with NO imports:
\`\`\`tsx
export default function App() {
  return (
    <div className="min-h-screen bg-gray-900 text-white flex items-center justify-center">
      <div className="text-center">
        <div className="animate-spin inline-block text-4xl mb-4">‚öôÔ∏è</div>
        <p className="text-gray-400">Building app modules...</p>
      </div>
    </div>
  )
}
\`\`\`

DO NOT add routing, Layout, or any page imports to App.tsx.
The Integration step will add routing after all modules are built.

Use this exact format for ALL files:
---FILE-START path="filepath"---
code
---FILE-END---`

    const success = await executeAIStep(prompt, 1)
    
    // After shell is created, run npm install and START dev server immediately
    if (success) {
      log('  üì¶ Installing dependencies...')
      try {
        const installResult = await window.jett.runNpmInstall(project.id)
        if (installResult.success) {
          log('  ‚úÖ Dependencies installed')
          
          // Start dev server now - App.tsx is a safe placeholder
          log('  üñ•Ô∏è Starting dev server...')
          const serverResult = await window.jett.startDevServer(project.id)
          if (serverResult.success && serverResult.port) {
            const url = `http://localhost:${serverResult.port}`
            setPreviewUrl(url)
            log(`  ‚úÖ Preview available at ${url}`)
          }
        } else {
          log(`  ‚ö†Ô∏è npm install warning: ${installResult.error || 'unknown'}`)
        }
      } catch (e: any) {
        log(`  ‚ö†Ô∏è npm install error: ${e.message}`)
      }
    }
    
    return success
  }

  /**
   * Step 3: Build Shared UI Components
   * Input: types/components.ts only
   * Output: components/ui/Button.tsx, Card.tsx, Modal.tsx, Input.tsx, index.ts
   */
  const buildSharedUI = async (): Promise<boolean> => {
    // Read component types
    let componentTypes = ''
    try {
      const result = await window.jett.readFile(project.id, 'src/types/components.ts')
      if (result.success) componentTypes = result.content
    } catch (e) {
      log('  ‚ö†Ô∏è Could not read component types')
    }

    const prompt = `Build shared UI components for a dark-themed app.

COMPONENT INTERFACES (implement these exactly):
${componentTypes || `
interface ButtonProps {
  children: React.ReactNode
  variant?: 'primary' | 'secondary' | 'ghost' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  disabled?: boolean
  loading?: boolean
  onClick?: () => void
  className?: string
}

interface CardProps {
  children: React.ReactNode
  padding?: 'none' | 'sm' | 'md' | 'lg'
  hover?: boolean
  onClick?: () => void
  className?: string
}

interface ModalProps {
  open: boolean
  onClose: () => void
  title?: string
  children: React.ReactNode
}

interface InputProps {
  value: string
  onChange: (value: string) => void
  placeholder?: string
  label?: string
  error?: string
  type?: 'text' | 'textarea'
}
`}

Generate these files:
1. src/components/ui/Button.tsx - All variants, loading spinner
2. src/components/ui/Card.tsx - Hover states, click handling
3. src/components/ui/Modal.tsx - Backdrop, escape to close
4. src/components/ui/Input.tsx - Label, error states, textarea support
5. src/components/ui/index.ts - Re-export all

STYLING RULES:
- Dark theme: bg-gray-800, bg-gray-900 backgrounds
- Text: text-gray-100 primary, text-gray-400 secondary
- Borders: border-gray-700
- Focus rings: focus:ring-2 focus:ring-blue-500
- Use Tailwind only, no custom CSS

Use this exact format:
---FILE-START path="filepath"---
code
---FILE-END---`

    return await executeAIStep(prompt, 2)
  }

  /**
   * Step 4+: Build Feature Module
   * Uses sub-task decomposition for complex modules (Option B + C)
   */
  const buildModule = async (spec: ModuleSpec): Promise<boolean> => {
    // Read ONLY types and shared UI - NOT other modules
    let typesContent = ''
    let sharedUIContent = ''
    
    try {
      const modelsResult = await window.jett.readFile(project.id, 'src/types/models.ts')
      const componentsResult = await window.jett.readFile(project.id, 'src/types/components.ts')
      if (modelsResult.success) typesContent += modelsResult.content + '\n'
      if (componentsResult.success) typesContent += componentsResult.content
    } catch (e) {
      log('  ‚ö†Ô∏è Could not read types')
    }

    try {
      const uiIndexResult = await window.jett.readFile(project.id, 'src/components/ui/index.ts')
      if (uiIndexResult.success) sharedUIContent = uiIndexResult.content
    } catch (e) {
      log('  ‚ö†Ô∏è Could not read shared UI')
    }

    const stepIndex = buildSteps.findIndex(s => s.moduleSpec?.name === spec.name)
    
    // Option C: Heuristic - should we decompose?
    const isComplex = spec.description.length > 100 || spec.components.length > 2
    
    if (!isComplex) {
      // Simple module - single API call (original behavior)
      log(`  üì¶ Building ${spec.name} (simple module)`)
      setSubTaskProgress(null)
      return await buildModuleSingle(spec, typesContent, sharedUIContent, stepIndex)
    }
    
    // Option B: Template-based decomposition for complex modules
    const totalSubTasks = spec.components.length + 1
    log(`  üì¶ Building ${spec.name} (${totalSubTasks} sub-tasks)`)
    
    // Sub-task 1: Main page structure
    setSubTaskProgress({ current: 1, total: totalSubTasks, name: 'index.tsx' })
    setStepStartTime(Date.now())
    setStepEstimate(25)
    setStepRemaining(25)
    // Sub-task 1: Main page (with retry)
    let pageSuccess = false
    let pageAttempts = 0
    const MAX_SUBTASK_RETRIES = 2
    
    while (!pageSuccess && pageAttempts < MAX_SUBTASK_RETRIES) {
      pageAttempts++
      if (pageAttempts > 1) {
        log(`  üîÑ Retry ${pageAttempts}/${MAX_SUBTASK_RETRIES}: index.tsx`)
        await new Promise(resolve => setTimeout(resolve, 2000))
      } else {
        log(`  ‚Üí Sub-task 1/${totalSubTasks}: index.tsx`)
      }
      pageSuccess = await buildModulePage(spec, typesContent, sharedUIContent, stepIndex)
    }
    
    if (!pageSuccess) {
      log(`  ‚ùå Main page failed after ${MAX_SUBTASK_RETRIES} attempts`)
      setSubTaskProgress(null)
      return false
    }
    
    // Delay between sub-tasks
    await new Promise(resolve => setTimeout(resolve, 3000))
    
    // Sub-task 2+: Each component (with retry)
    
    for (let i = 0; i < spec.components.length; i++) {
      const componentName = spec.components[i]
      setSubTaskProgress({ current: i + 2, total: totalSubTasks, name: componentName })
      
      let componentSuccess = false
      let attempts = 0
      
      while (!componentSuccess && attempts < MAX_SUBTASK_RETRIES) {
        attempts++
        
        // Restart timer for each attempt
        setStepStartTime(Date.now())
        setStepEstimate(20)
        setStepRemaining(20)
        
        if (attempts > 1) {
          log(`  üîÑ Retry ${attempts}/${MAX_SUBTASK_RETRIES}: ${componentName}`)
          await new Promise(resolve => setTimeout(resolve, 2000))
        } else {
          log(`  ‚Üí Sub-task ${i + 2}/${totalSubTasks}: ${componentName}`)
        }
        
        componentSuccess = await buildModuleComponent(spec, componentName, typesContent, sharedUIContent, stepIndex)
      }
      
      if (!componentSuccess) {
        log(`  ‚ö†Ô∏è Component ${componentName} failed after ${MAX_SUBTASK_RETRIES} attempts, continuing...`)
      }
      
      // Delay between components
      if (i < spec.components.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 3000))
      }
    }
    
    setSubTaskProgress(null)
    return true
  }

  // Build entire module in single call (for simple modules)
  const buildModuleSingle = async (
    spec: ModuleSpec, 
    typesContent: string, 
    sharedUIContent: string,
    stepIndex: number
  ): Promise<boolean> => {
    const prompt = `Build the "${spec.name}" module for a React app.

MODULE SPEC:
- Name: ${spec.name}
- Route: ${spec.route}
- Description: ${spec.description}
- Expected components: ${spec.components.join(', ')}

AVAILABLE TYPES (use these):
${typesContent}

AVAILABLE SHARED UI (import from @/components/ui):
${sharedUIContent || 'Button, Card, Modal, Input'}

WHAT TO BUILD:
1. pages/${spec.name}/index.tsx - Main page component (default export)
2. pages/${spec.name}/components/*.tsx - Supporting components

CRITICAL CONSTRAINTS:
- Import types from '@/types'
- Import UI from '@/components/ui'  
- Use react-router-dom for navigation (useNavigate, useParams)
- Include mock data for demonstration
- This module knows NOTHING about other modules
- Do NOT import from other pages/*

STRUCTURE:
- Main page handles state and orchestration
- Sub-components are presentational
- Max 3 components per module

Use this exact format:
---FILE-START path="filepath"---
code
---FILE-END---`

    return await executeAIStep(prompt, stepIndex)
  }

  // Build just the main page index.tsx
  const buildModulePage = async (
    spec: ModuleSpec, 
    typesContent: string, 
    sharedUIContent: string,
    stepIndex: number
  ): Promise<boolean> => {
    const prompt = `Build ONLY the main page file for "${spec.name}" module.

MODULE SPEC:
- Name: ${spec.name}
- Route: ${spec.route}  
- Description: ${spec.description}
- Components that will exist: ${spec.components.join(', ')}

AVAILABLE TYPES:
${typesContent}

AVAILABLE SHARED UI (import from @/components/ui):
${sharedUIContent || 'Button, Card, Modal, Input'}

BUILD ONLY THIS FILE:
- pages/${spec.name}/index.tsx

This is the main orchestrator page. It should:
- Import from '@/types' and '@/components/ui'
- Import components from './components/ComponentName' (they will be built next)
- Manage page-level state
- Include mock data for demonstration
- Handle routing with useNavigate, useParams

OUTPUT EXACTLY ONE FILE:
---FILE-START path="src/pages/${spec.name}/index.tsx"---
code
---FILE-END---`

    return await executeAIStep(prompt, stepIndex)
  }

  // Build a single component for a module
  const buildModuleComponent = async (
    spec: ModuleSpec,
    componentName: string,
    typesContent: string, 
    sharedUIContent: string,
    stepIndex: number
  ): Promise<boolean> => {
    const prompt = `Build ONLY the "${componentName}" component for the "${spec.name}" module.

CONTEXT:
- Module: ${spec.name}
- Module description: ${spec.description}
- This component: ${componentName}

AVAILABLE TYPES:
${typesContent}

AVAILABLE SHARED UI (import from @/components/ui):
${sharedUIContent || 'Button, Card, Modal, Input'}

BUILD ONLY THIS FILE:
- pages/${spec.name}/components/${componentName}.tsx

This is a presentational/feature component. It should:
- Import from '@/types' and '@/components/ui' as needed
- Accept props from the parent page
- Be focused on its single responsibility
- Use TypeScript interfaces for props

OUTPUT EXACTLY ONE FILE:
---FILE-START path="src/pages/${spec.name}/components/${componentName}.tsx"---
code
---FILE-END---`

    return await executeAIStep(prompt, stepIndex)
  }

  /**
   * Code Simplification Pass
   * Runs after module is built to reduce complexity
   */
  const simplifyModule = async (moduleName: string, stepIndex: number): Promise<boolean> => {
    log(`  üßπ Simplifying ${moduleName}...`)
    
    // Read the files just created
    const files: Record<string, string> = {}
    try {
      const listResult = await window.jett.listFiles(project.id)
      if (listResult.success && listResult.files) {
        const moduleFiles = listResult.files.filter((f: string) => 
          f.startsWith(`src/pages/${moduleName}/`) && f.endsWith('.tsx')
        )
        
        for (const filePath of moduleFiles) {
          const readResult = await window.jett.readFile(project.id, filePath)
          if (readResult.success && readResult.content) {
            files[filePath] = readResult.content
          }
        }
      }
    } catch (e) {
      log('  ‚ö†Ô∏è Could not read module files for simplification')
      return true // Don't fail the build, just skip simplification
    }
    
    if (Object.keys(files).length === 0) {
      return true // Nothing to simplify
    }
    
    const filesContent = Object.entries(files)
      .map(([path, content]) => `--- ${path} ---\n${content}`)
      .join('\n\n')
    
    const prompt = `Simplify this code while keeping all functionality. Apply "the dumbest thing that works" principle.

FILES TO SIMPLIFY:
${filesContent}

SIMPLIFICATION RULES:
1. Remove unused imports
2. Simplify complex conditionals (use early returns instead of nested ifs)
3. Extract repeated code into small helper functions (only if used 3+ times)
4. Remove over-engineered abstractions
5. Prefer explicit over clever
6. Keep state minimal - derive what you can
7. Remove console.logs and debug code
8. Simplify type definitions (avoid unnecessary generics)

CONSTRAINTS:
- Keep ALL functionality intact
- Keep ALL visual appearance identical
- Don't change file structure
- Don't add new dependencies
- Output only files that changed

If a file is already simple, don't output it.

Output ONLY files that need simplification:
---FILE-START path="filepath"---
simplified code
---FILE-END---`

    try {
      const result = await window.jett.claudeApi(
        apiKey,
        JSON.stringify([{ role: 'user', content: prompt }]),
        undefined,
        provider,
        model
      )

      if (!result.success) {
        log(`  ‚ö†Ô∏è Simplification skipped: ${result.error}`)
        return true // Don't fail the build
      }

      // Extract and write simplified files
      const fileRegex = /---FILE-START\s*path="([^"]+)"\s*---([\s\S]*?)---FILE-END---/g
      let match
      let filesSimplified = 0

      while ((match = fileRegex.exec(result.text)) !== null) {
        const [, filePath, content] = match
        const trimmedContent = content.trim()
        
        if (trimmedContent.length > 0) {
          await window.jett.writeFile(project.id, filePath, trimmedContent)
          filesSimplified++
        }
      }
      
      if (filesSimplified > 0) {
        log(`  ‚ú® Simplified ${filesSimplified} file${filesSimplified > 1 ? 's' : ''}`)
      } else {
        log(`  ‚úÖ Code already simple`)
      }
      
      return true
    } catch (error: any) {
      log(`  ‚ö†Ô∏è Simplification error: ${error.message}`)
      return true // Don't fail the build
    }
  }

  /**
   * Final Step: Integration
   * GENERATES FILES DIRECTLY - NO AI INVOLVED
   */
  const runIntegration = async (): Promise<boolean> => {
    log('  üîó Running integration...')
    
    // Get list of ACTUAL files in src/pages
    let pageFiles: string[] = []
    try {
      const result = await window.jett.listFiles(project.id)
      if (result.success && result.files) {
        const pageIndexFiles = result.files.filter((f: string) => 
          f.startsWith('src/pages/') && f.endsWith('/index.tsx')
        )
        log(`  üìÇ Found ${pageIndexFiles.length} page index files`)
        
        pageFiles = pageIndexFiles
          .map((f: string) => f.split('/')[2])
          .filter((f: string, i: number, arr: string[]) => arr.indexOf(f) === i)
          
        log(`  üìÅ Page folders: ${pageFiles.slice(0, 5).join(', ')}${pageFiles.length > 5 ? '...' : ''}`)
      }
    } catch (e: any) {
      log(`  ‚ö†Ô∏è Could not list page files: ${e.message}`)
    }
    
    if (pageFiles.length === 0) {
      const moduleSteps = buildSteps.filter(s => s.type === 'module' && s.status === 'complete')
      pageFiles = moduleSteps.map(s => s.moduleSpec!.name)
    }
    
    if (pageFiles.length === 0) {
      log('  ‚ùå No page modules found!')
      return false
    }

    // Helper to convert to kebab-case for routes
    const toKebabCase = (str: string) => str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
      .toLowerCase()

    // Helper to make valid JS identifier (remove hyphens, special chars)
    const toValidIdentifier = (str: string) => str
      .replace(/[^a-zA-Z0-9]/g, '')  // Remove anything not alphanumeric

    const appName = project.prd?.overview?.name || 'App'

    // ========== GENERATE main.tsx ==========
    const mainTsx = `import React from 'react'
import ReactDOM from 'react-dom/client'
import { BrowserRouter } from 'react-router-dom'
import App from './App'
import './styles/index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
)
`

    // ========== GENERATE Layout.tsx ==========
    const navLinks = pageFiles.map((folder, i) => {
      const path = i === 0 ? '/' : `/${toKebabCase(folder)}`
      const label = folder.replace(/([A-Z])/g, ' $1').trim()
      return `          <Link to="${path}" className="px-3 py-2 rounded hover:bg-gray-700 text-sm">${label}</Link>`
    }).join('\n')

    const layoutTsx = `import { Link } from 'react-router-dom'

interface LayoutProps {
  children: React.ReactNode
}

export default function Layout({ children }: LayoutProps) {
  return (
    <div className="min-h-screen bg-gray-900 text-white">
      <header className="bg-gray-800 border-b border-gray-700">
        <div className="max-w-7xl mx-auto px-4 py-3">
          <div className="flex items-center justify-between">
            <h1 className="text-xl font-bold">${appName}</h1>
            <nav className="flex gap-2 flex-wrap">
${navLinks}
            </nav>
          </div>
        </div>
      </header>
      <main className="max-w-7xl mx-auto px-4 py-6">
        {children}
      </main>
    </div>
  )
}
`

    // ========== GENERATE App.tsx ==========
    const lazyImports = pageFiles.map(folder => {
      const identifier = toValidIdentifier(folder)
      return `const ${identifier} = lazy(() => import('./pages/${folder}'))`
    }).join('\n')
    
    const routes = pageFiles.map((folder, i) => {
      const identifier = toValidIdentifier(folder)
      const path = i === 0 ? '/' : `/${toKebabCase(folder)}`
      return `          <Route path="${path}" element={<${identifier} />} />`
    }).join('\n')

    const appTsx = `import { lazy, Suspense } from 'react'
import { Routes, Route } from 'react-router-dom'
import Layout from './components/Layout'

${lazyImports}

export default function App() {
  return (
    <Layout>
      <Suspense fallback={<div className="p-8 text-center text-gray-400">Loading...</div>}>
        <Routes>
${routes}
        </Routes>
      </Suspense>
    </Layout>
  )
}
`

    // ========== GENERATE index.css (minimal) ==========
    const indexCss = `@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}
`

    // ========== WRITE ALL FILES ==========
    try {
      await window.jett.writeFile(project.id, 'src/main.tsx', mainTsx)
      log('  üìÑ Created: src/main.tsx')
      
      await window.jett.writeFile(project.id, 'src/components/Layout.tsx', layoutTsx)
      log('  üìÑ Created: src/components/Layout.tsx')
      
      await window.jett.writeFile(project.id, 'src/App.tsx', appTsx)
      log('  üìÑ Created: src/App.tsx')
      
      await window.jett.writeFile(project.id, 'src/styles/index.css', indexCss)
      log('  üìÑ Created: src/styles/index.css')
      
      log('  ‚úÖ Integration complete - 4 files created')
      setLastFileUpdate(Date.now())
      return true
    } catch (error: any) {
      log(`  ‚ùå Failed to write files: ${error.message}`)
      return false
    }
  }

  // ========================================
  // AI EXECUTION HELPER
  // ========================================

  const executeAIStep = async (prompt: string, stepIndex: number, retryCount = 0): Promise<boolean> => {
    const systemPrompt = getSystemPrompt()
    
    // Get appropriate model for this step type
    const step = buildSteps[stepIndex]
    const stepType = (step?.type || 'module') as BuildStepType
    const { provider: stepProvider, model: stepModel } = getModelForStep(stepType, provider, model)

    try {
      // Build prompt with self-healing context if on retry
      let fullPrompt = `${systemPrompt}\n\n${prompt}`
      if (retryContext?.code) {
        fullPrompt = `${systemPrompt}

## YOUR EXISTING CODE (what you generated)
${retryContext.code}

## TASK
Fix the issues in the code above. You can either:
1. Output complete replacement files using ---FILE-START path="..."--- format
2. Output surgical patches using this format:
---PATCH path="src/path/to/file.tsx"---
OLD:
\`\`\`
exact code to find
\`\`\`
NEW:
\`\`\`
replacement code
\`\`\`
---END-PATCH---

Patches are preferred for small fixes. Use full files only if major rewrite needed.

${prompt}`
      }
      
      const result = await window.jett.claudeApi(
        apiKey,
        JSON.stringify([{ role: 'user', content: fullPrompt }]),
        undefined,
        stepProvider,
        stepModel
      )

      if (!result.success) {
        // Check for rate limit error
        if (result.error?.includes('rate limit') || result.error?.includes('429')) {
          if (retryCount < 3) {
            const waitTime = Math.pow(2, retryCount + 1) * 30 // 60s, 120s, 240s
            log(`  ‚è≥ Rate limited - waiting ${waitTime}s before retry...`)
            await new Promise(resolve => setTimeout(resolve, waitTime * 1000))
            return executeAIStep(prompt, stepIndex, retryCount + 1)
          }
        }
        log(`  ‚ùå API Error: ${result.error}`)
        return false
      }

      // Extract and write files
      const fileRegex = /---FILE-START\s*path="([^"]+)"\s*---([\s\S]*?)---FILE-END---/g
      let match
      let filesWritten = 0
      const filesCreated: string[] = []

      while ((match = fileRegex.exec(result.text)) !== null) {
        const [, filePath, content] = match
        await window.jett.writeFile(project.id, filePath, content.trim())
        log(`  üìÑ Created: ${filePath}`)
        filesWritten++
        filesCreated.push(filePath)
      }

      // Also check for patches (self-healing mode)
      const { applied: patchesApplied } = await applyPatches(result.text)
      if (patchesApplied > 0) {
        log(`  üîß Applied ${patchesApplied} patches`)
        setLastFileUpdate(Date.now())
      }

      // Check for explicit completion signal
      const completion = parseCompletionSignal(result.text)
      
      if (completion.complete) {
        if (completion.success) {
          addFilesToStep(stepIndex, filesCreated)
          setLastFileUpdate(Date.now())
          log(`  ‚úÖ Task complete (${filesWritten} files)`)
          return true
        } else {
          log(`  ‚ùå Task failed: ${completion.reason || 'Unknown error'}`)
          return false
        }
      }
      
      // Fallback: infer success from file output
      if (filesWritten > 0) {
        addFilesToStep(stepIndex, filesCreated)
        setLastFileUpdate(Date.now())
        log(`  ‚úÖ ${filesWritten} files created (no completion signal)`)
        return true
      } else {
        log(`  ‚ö†Ô∏è No files extracted from response`)
        return false
      }
    } catch (error: any) {
      log(`  ‚ùå Error: ${error.message}`)
      return false
    }
  }

  // ========================================
  // BUILD ORCHESTRATION
  // ========================================

  const startBuild = async () => {
    if (buildSteps.length === 0) {
      await generateBuildPlan()
      return
    }

    setIsBuilding(true)
    setStopRequested(false)
    setHasBuildErrors(false)
    setBuildLog([])
    
    // Start total build timer
    if (!totalBuildStart) {
      setTotalBuildStart(Date.now())
      setTotalElapsed(0)
    }
    
    log('üöÄ Starting isolated module build...')

    // Initialize progress log
    initProgressLog(project.prd?.overview?.name || project.name || 'Untitled')

    // Find first incomplete step
    const startIndex = buildSteps.findIndex(s => s.status !== 'complete')
    if (startIndex === -1) {
      log('‚úÖ All steps already complete!')
      
      // useEffect will detect all-complete and start preview
      setTotalBuildStart(null)
      setIsBuilding(false)
      return
    }

    // Execute steps sequentially with auto-fix retry
    const MAX_RETRIES = getBuildSettings().maxIterations
    let allStepsCompleted = true
    
    for (let i = startIndex; i < buildSteps.length; i++) {
      // Check if stop was requested
      if (stopRequested) {
        log('\n‚èπÔ∏è Build stopped by user')
        break
      }
      
      setCurrentStepIndex(i)
      
      let success = false
      let attempts = 0
      
      while (!success && attempts < MAX_RETRIES && !stopRequested) {
        attempts++
        
        // Log step attempt
        logStepStart(buildSteps[i], attempts)
        
        if (attempts > 1) {
          log(`  üîÑ Auto-fix attempt ${attempts}/${MAX_RETRIES}...`)
          // Read existing code for self-healing context
          log(`  üìñ Reading generated files for context...`)
          const codeContext = await readAllProjectFiles()
          setRetryContext({ code: codeContext })
          // Brief pause before retry
          await new Promise(resolve => setTimeout(resolve, 1500))
        } else {
          setRetryContext(null)
        }
        
        success = await executeBuildStep(buildSteps[i], i)
      }
      
      // Log step result
      if (success) {
        logStepComplete(buildSteps[i], attempts)
      } else {
        logStepFailed(buildSteps[i], attempts)
      }
      
      if (!success) {
        log(`\n‚ùå Build stopped at step ${i + 1}: ${buildSteps[i].name} (failed after ${MAX_RETRIES} attempts)`)
        allStepsCompleted = false
        break
      }
      
      // Brief pause between steps (helps avoid rate limits)
      await new Promise(resolve => setTimeout(resolve, 3000))
    }

    setCurrentStepIndex(null)
    log('\nüèÅ Build process finished')
    
    // Write progress log
    writeProgressLog(
      project.id,
      project.prd?.overview?.name || project.name || 'Untitled',
      buildSteps,
      totalElapsed
    )
    
    // Stop total build timer (keep elapsed value for display)
    setTotalBuildStart(null)
    
    if (allStepsCompleted) {
      // useEffect will detect all-complete and start preview automatically
      setIsBuilding(false)
    } else {
      setHasBuildErrors(true)
      setIsBuilding(false)
      log('‚ö†Ô∏è Some steps failed - fix errors and click "Continue Build" to retry')
    }
  }

  // ========================================
  // CONSOLIDATED PREVIEW MANAGEMENT
  // ========================================

  /**
   * Single source of truth for starting preview
   * Called from: executeBuildFromStep, rebuildStep, useEffect
   */
  const ensurePreviewRunning = async () => {
    // Check if all steps complete
    const allComplete = buildSteps.length > 0 && buildSteps.every(s => s.status === 'complete')
    if (!allComplete) return
    
    // Check if preview already running
    if (previewUrl) return
    
    log('üñ•Ô∏è Starting dev server...')
    setPreviewFailed(false)
    
    try {
      // Ensure dependencies installed
      try {
        const installResult = await window.jett.runNpmInstall(project.id)
        if (installResult.success) {
          log('‚úÖ Dependencies ready')
        }
      } catch (e: any) {
        log(`‚ö†Ô∏è npm install: ${e.message}`)
      }
      
      // Start server
      const result = await window.jett.startDevServer(project.id)
      if (result.success && (result.port || result.url)) {
        const url = result.url || `http://localhost:${result.port}`
        setPreviewUrl(url)
        setPreviewFailed(false)
        log(`‚úÖ Preview available at ${url}`)
        
        // v1.5.0: Run smoke test
        runPostBuildTest(url)
      } else {
        setPreviewFailed(true)
        log(`‚ùå Server failed: ${result.error || 'Unknown error'}`)
      }
    } catch (error: any) {
      setPreviewFailed(true)
      log(`‚ùå Server error: ${error.message}`)
    }
  }

  /**
   * v1.5.0: Run smoke test after build completes
   */
  const runPostBuildTest = async (url: string) => {
    log('üß™ Running smoke test...')
    setTestStatus('running')
    
    await new Promise(resolve => setTimeout(resolve, 2000))
    
    const result = await runSmokeTest(url)
    
    if (result.passed) {
      setTestStatus('passed')
      log('‚úÖ Smoke test passed' + (result.duration ? ` (${result.duration}ms)` : ''))
    } else {
      setTestStatus('failed')
      log(`‚ùå Smoke test failed: ${result.error}`)
    }
  }

  // Auto-start preview when all steps complete
  useEffect(() => {
    const allComplete = buildSteps.length > 0 && buildSteps.every(s => s.status === 'complete')
    if (allComplete && !previewUrl && !isBuilding) {
      ensurePreviewRunning()
    }
  }, [buildSteps, previewUrl, isBuilding])

  const rebuildStep = async (index: number) => {
    setIsBuilding(true)
    setCurrentStepIndex(index)
    await executeBuildStep(buildSteps[index], index)
    setCurrentStepIndex(null)
    setIsBuilding(false)
    
    // If this was Integration step, ensure preview starts
    if (buildSteps[index]?.type === 'integration') {
      await ensurePreviewRunning()
    }
  }

  // Legacy startDevServer - now just calls ensurePreviewRunning
  const startDevServer = async () => {
    await ensurePreviewRunning()
  }

  // ========================================
  // RENDER
  // ========================================

  const completedSteps = buildSteps.filter(s => s.status === 'complete').length
  const totalSteps = buildSteps.length

  return (
    <div className="h-full flex">
      {/* Left Panel - Build Steps */}
      <div className="w-80 border-r border-[var(--border-primary)] flex flex-col">
        <div className="p-4 border-b border-[var(--border-primary)]">
          <div className="flex items-center justify-between mb-2">
            <h2 className="text-lg font-semibold">Build Steps</h2>
            <span className="text-sm text-[var(--text-tertiary)]">
              {completedSteps}/{totalSteps}
            </span>
          </div>
          
          {buildSteps.length === 0 ? (
            <div className="w-full px-4 py-3 rounded-lg text-sm text-center" style={{ background: 'var(--bg-secondary)' }}>
              <IconClock size={16} className="inline-block animate-spin mr-2" />
              Generating build plan...
            </div>
          ) : isBuilding ? (
            <button
              onClick={() => setStopRequested(true)}
              className="w-full px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium flex items-center justify-center gap-2"
            >
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                <rect x="6" y="6" width="12" height="12" rx="2" />
              </svg>
              Stop Build
            </button>
          ) : (
            <button
              onClick={startBuild}
              className="w-full px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-medium flex items-center justify-center gap-2"
            >
              <IconBuild size={16} />
              {completedSteps > 0 ? 'Continue Build' : 'Start Build'}
            </button>
          )}
        </div>

        {/* Steps List */}
        <div className="flex-1 overflow-auto p-2">
          {buildSteps.map((step, index) => {
            const isCurrentStep = currentStepIndex === index
            const isStepActive = step.status === 'building' || isCurrentStep
            
            return (
            <div
              key={step.id}
              className={`p-3 rounded-lg mb-2 ${
                isCurrentStep
                  ? 'bg-blue-600/20 border border-blue-500/50'
                  : step.status === 'complete'
                  ? 'bg-green-600/10 border border-green-500/30'
                  : step.status === 'failed'
                  ? 'bg-red-600/10 border border-red-500/30'
                  : 'bg-[var(--bg-secondary)] border border-[var(--border-primary)]'
              }`}
            >
              {/* Header row with icon, name, timer/rebuild */}
              <div className="flex items-start gap-2">
                {/* Status icon */}
                <div className="pt-0.5 flex-shrink-0 w-4">
                  {step.status === 'complete' ? (
                    <IconCheck size={14} className="text-green-500" />
                  ) : isStepActive ? (
                    <IconClock size={14} className="text-blue-500 animate-spin" />
                  ) : step.status === 'failed' ? (
                    <span className="text-red-500 text-sm">‚úï</span>
                  ) : (
                    <span className="w-3.5 h-3.5 rounded-full border border-gray-500 block" />
                  )}
                </div>
                
                {/* Content column */}
                <div className="flex-1 min-w-0">
                  {/* Name row */}
                  <div className="flex items-center justify-between gap-2">
                    <span className="font-medium text-sm">{step.name}</span>
                    
                    {/* Timer or rebuild button */}
                    {isStepActive && stepStartTime ? (
                      <div className="flex items-center gap-2 flex-shrink-0">
                        <span className="text-base font-mono text-blue-400 tabular-nums">
                          {formatTime(stepRemaining)}
                        </span>
                        <div className="w-10 h-1.5 bg-gray-700 rounded-full overflow-hidden">
                          <div 
                            className="h-full bg-blue-500 transition-all duration-1000"
                            style={{ 
                              width: stepEstimate > 0 
                                ? `${Math.min(100, ((stepEstimate - stepRemaining) / stepEstimate) * 100)}%` 
                                : '0%' 
                            }}
                          />
                        </div>
                      </div>
                    ) : (step.status === 'failed' || step.status === 'complete') && !isBuilding ? (
                      <button
                        onClick={() => rebuildStep(index)}
                        className="p-1 hover:bg-gray-700 rounded opacity-50 hover:opacity-100 flex-shrink-0"
                        title="Rebuild this step"
                      >
                        <IconRefresh size={14} />
                      </button>
                    ) : null}
                  </div>
                  
                  {/* Description - only show if not too long */}
                  <p className="text-xs text-[var(--text-tertiary)] mt-0.5 line-clamp-2">
                    {step.description}
                  </p>
                  
                  {/* Sub-task progress (when building module) */}
                  {isStepActive && subTaskProgress && (
                    <div className="mt-2 px-2 py-1.5 bg-blue-600/30 rounded text-xs">
                      <span className="text-blue-300">
                        Building {subTaskProgress.current}/{subTaskProgress.total}: {subTaskProgress.name}
                      </span>
                    </div>
                  )}
                  
                  {/* File count */}
                  {step.filesCreated.length > 0 && !isStepActive && (
                    <div className="mt-1 text-xs text-[var(--text-tertiary)]">
                      {step.filesCreated.length} files
                    </div>
                  )}
                </div>
              </div>
            </div>
          )})}
        </div>

        {/* Build Log */}
        <div className="border-t border-[var(--border-primary)] max-h-48 overflow-auto">
          <div className="p-2 text-xs font-mono text-[var(--text-tertiary)]">
            {buildLog.slice(-20).map((log, i) => (
              <div key={i} className="py-0.5">{log}</div>
            ))}
          </div>
        </div>
      </div>

      {/* Right Panel - Preview/Code */}
      <div className="flex-1 flex flex-col">
        {/* Tab Switcher */}
        <div className="flex items-center justify-between border-b border-[var(--border-primary)] px-4">
          <div className="flex items-center">
            <button
              onClick={() => setRightPanelTab('preview')}
              className={`px-4 py-3 text-sm font-medium border-b-2 ${
                rightPanelTab === 'preview'
                  ? 'border-blue-500 text-blue-500'
                  : 'border-transparent text-[var(--text-tertiary)]'
              }`}
            >
              Preview
            </button>
            <button
              onClick={() => setRightPanelTab('code')}
              className={`px-4 py-3 text-sm font-medium border-b-2 ${
                rightPanelTab === 'code'
                  ? 'border-blue-500 text-blue-500'
                  : 'border-transparent text-[var(--text-tertiary)]'
              }`}
            >
              <IconCode size={14} className="inline mr-1" />
              Code
            </button>
          </div>
          
          {/* Open in Browser button + Total Time */}
          <div className="flex items-center gap-3">
            {/* v1.5.0: Test status */}
            {testStatus !== 'idle' && (
              <div className={`flex items-center gap-2 text-sm px-2 py-1 rounded ${
                testStatus === 'passed' ? 'text-green-500 bg-green-500/10' :
                testStatus === 'failed' ? 'text-red-500 bg-red-500/10' :
                'text-blue-500 bg-blue-500/10'
              }`}>
                {testStatus === 'running' && <IconClock size={14} className="animate-spin" />}
                {testStatus === 'passed' && <IconCheck size={14} />}
                {testStatus === 'failed' && <span>‚úï</span>}
                <span>{testStatus === 'running' ? 'Testing...' : testStatus === 'passed' ? 'Tests passed' : 'Tests failed'}</span>
              </div>
            )}
            
            {/* Total build time */}
            {(isBuilding || totalElapsed > 0) && (
              <div className="flex items-center gap-2 text-sm">
                <span className="text-[var(--text-tertiary)]">Total Build Time:</span>
                <span className="font-mono text-blue-400 tabular-nums">
                  {formatTime(totalElapsed)}
                </span>
              </div>
            )}
            
            {previewUrl && !isBuilding && (
              <button
                onClick={() => window.open(previewUrl, '_blank')}
                className="px-3 py-1.5 text-xs font-medium bg-gray-700 hover:bg-gray-600 rounded flex items-center gap-1.5"
                title="Open in external browser"
              >
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
                  <polyline points="15 3 21 3 21 9" />
                  <line x1="10" y1="14" x2="21" y2="3" />
                </svg>
                Open in Browser
              </button>
            )}
          </div>
        </div>

        {/* Content */}
        <div className="flex-1 overflow-hidden">
          {rightPanelTab === 'preview' ? (
            isBuilding ? (
              <div className="flex items-center justify-center h-full text-[var(--text-tertiary)]">
                <div className="text-center">
                  {/* Countdown Timer */}
                  <div className="text-6xl font-mono mb-4 text-blue-400">
                    {formatTime(stepRemaining)}
                  </div>
                  <div className="w-48 h-2 bg-gray-700 rounded-full mx-auto mb-4 overflow-hidden">
                    <div 
                      className="h-full bg-blue-500 transition-all duration-1000"
                      style={{ 
                        width: stepEstimate > 0 
                          ? `${Math.min(100, ((stepEstimate - stepRemaining) / stepEstimate) * 100)}%` 
                          : '0%' 
                      }}
                    />
                  </div>
                  <p className="text-sm">
                    Building step {(currentStepIndex ?? 0) + 1} of {buildSteps.length}
                  </p>
                  {subTaskProgress && (
                    <p className="text-sm text-blue-400 mt-1">
                      Sub-task {subTaskProgress.current}/{subTaskProgress.total}: {subTaskProgress.name}
                    </p>
                  )}
                  <p className="text-xs mt-2 opacity-60">
                    {stepRemaining === 0 ? 'Almost done...' : 'Estimated time remaining'}
                  </p>
                </div>
              </div>
            ) : previewUrl ? (
              <webview
                ref={webviewRef}
                src={previewUrl}
                className="w-full h-full"
                // @ts-ignore
                allowpopups="true"
              />
            ) : (
              <div className="flex items-center justify-center h-full text-[var(--text-tertiary)]">
                <div className="text-center">
                  {buildSteps.some(s => s.status === 'failed') ? (
                    <>
                      <div className="text-4xl mb-4">‚ö†Ô∏è</div>
                      <p className="text-yellow-500">Some steps failed</p>
                      <p className="text-sm mt-2">Click "Continue Build" to retry</p>
                    </>
                  ) : buildSteps.length > 0 && buildSteps.every(s => s.status === 'complete') ? (
                    <>
                      <IconRocket size={48} className="mx-auto mb-4 opacity-50" />
                      {previewFailed ? (
                        <>
                          <p className="text-yellow-500 mb-3">Preview server failed to start</p>
                          <button
                            onClick={() => ensurePreviewRunning()}
                            className="px-4 py-2 bg-blue-600 hover:bg-blue-500 text-white rounded-lg flex items-center gap-2 mx-auto"
                          >
                            <IconRefresh size={16} />
                            Retry Preview
                          </button>
                          <p className="text-xs mt-3 opacity-60">Or click "Open in Browser" after retrying</p>
                        </>
                      ) : (
                        <p>Build complete ‚Äî starting preview...</p>
                      )}
                    </>
                  ) : buildSteps.length > 0 ? (
                    <>
                      <IconRocket size={48} className="mx-auto mb-4 opacity-50" />
                      <p>Click "Continue Build" to resume</p>
                    </>
                  ) : (
                    <>
                      <IconRocket size={48} className="mx-auto mb-4 opacity-50" />
                      <p>Click "Start Build" to begin</p>
                    </>
                  )}
                </div>
              </div>
            )
          ) : (
            <CodePanel 
              projectId={project.id} 
              key={lastFileUpdate}
            />
          )}
        </div>
      </div>
    </div>
  )
}
